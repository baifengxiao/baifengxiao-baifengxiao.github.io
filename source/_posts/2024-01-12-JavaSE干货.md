---
title: JavaSE干货
tags:
  - 学而时习之
  - JavaSE
categories:
  - 学而时习之
abbrlink: b7352c4c
date: '2024-01-12 02:21:01'
description: JavaSE干货
---

### 1

#### **标识符的命名规范**

1.包名：多单词组成时所有字母都小写：xxxyyyzzz
2.类名、接口名：多单词组成时，**所有单词的首字母大写**：XxxYyyZzz
3.变量名、方法名：多单词组成时，**第一个单词首字母小写，第二个单词开始每个单词首字母大写**：xxxYyyZzz
4.常量名：所有字母都大写。**多单词时每个单词用下划线连接**：XXX_YYY_ZZZ

#### java采用unicode字符集

#### **变量的作用:用于在内存中保存数据**

#### 变量的使用注意事项：

1. 变量必须**先声明才能使用**,否则报错：错误: 找不到符号

2. 变量必须**先初始化值**才能使用,否则，错误: 可能尚未初始化变量age

-------

### 2

#### 计算机底层存储的是整数的**补码**。

#### **补码：正整数的补码与原码一致，负整数的补码是在反码基础上加1**

#### 浮点型系列精度

float：

**精度：可展示小数点后七位，小数点后六位准确，第七位不准确**

double

**精度：可展示小数点后十六位，小数点后十五位准确，第十六位不准确** 

#### **当byte、char、short三种类型的变量做运算时，结果为int型**

short s1 = 10;
//s1 = s1 + 2;//`编译失败`
s1 += 2;//结论：`不会改变变量本身的数据类型`

#### **位运算符的运算过程都是基于补码运算，但是看结果，我们得换成原码，再换成十进制看结果**

#### 如何区分&,|,^是逻辑运算符还是位运算符？

**如果操作数是boolean类型，就是逻辑运算符，如果操作数是整数，那么就是位运算符。**

----------

### 3

#### 如果if-else结构中的执行语句只有一行时，对应的一对{}可以省略的。但是，不建议大家省略。

####  witch结构中的表达式，只能是如下的6种数据类型之一： byte 、short、char、int、枚举类型(JDK5.0新增)、String类型(JDK7.0新增)

####  case 之后只能声明常量。不能声明范围。

#### 时间复杂度 、空间复杂度 （衡量算法的好坏）

#### while(true){ 循环体}，`除循环体外还需要执行小括号里的表达式`

--------------------

### 4

#### `创建数组对象会在内存中开辟一整块连续的空间`

#### 数组元素是char型：0或'\u0000'，而非'0'

#### 数组内存解析

![image.png](http://cdn.this0.com/blog/img/1676455218210-a9e3eb93-f232-4837-b110-7fa3baa24633.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000001&Signature=GOV9zW7Oi5fETbTTRIZ052bmnwU=&x-oss-process=style/cdn.this0)

#### 栈里面放地址，局部变量放栈里面 堆空间开辟结构，放地址值（首地址值)

[![image.png](http://cdn.this0.com/blog/img/1676543604055-cf9577ec-5c1e-4048-8dff-696307dce0d3.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=9XHMxkhwjcWUNvwQii6/5A9q2zA=&x-oss-process=style/cdn.this0)](http://cdn.this0.com/blog/img/1676543604055-cf9577ec-5c1e-4048-8dff-696307dce0d3.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000001&Signature=fDrshKLq6OAEAn9VoYxSqZ2ca40=&x-oss-process=style/cdn.this0)

栈里面放地址，局部变量放栈里面 堆空间开辟结构，放地址值（首地址值)

#### 小知识：一旦程序出现异常，未处理时，就终止执行。

--------------

### 5

面向对象程序设计的**重点是类的设计**
**设计类，就是设计类的成员。**

#### `类的实例化与对象的内存解析`

//TODO

内存解析：
编译完源程序以后，生成一个或多个字节码文件。
我们使用JVM中的类的加载器和解释器对生成的字节码文件进行解释运行。

意味着，需要将字节码文件对应的类加载到内存中，涉及到内存解析。

虚拟机栈，即为平时提到的栈结构。我们将局部变量存储在栈结构中 堆，我们将new出来的结构（比如：数组、对象）加载在堆空间中。

补充：对象的属性（非static的)加载在堆空间中。

方法区：类的加载信息、常量池、静态域

如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。（非static的)

局部变量：没默认初始化值。

#### 2.4 在内存中加载的位置：

属性：加载到堆空间中（非static） 局部变量：加载到栈空间

static、final、abstract来修饰的方法,后面再讲

return关键字后面不可以声明执行语句。

### 7. `方法的内存解析`

### 8. `对象数组的使用及内存解析`

#### 1. 方法的重载的概念

定义：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。

两同一不同:同一个类、相同方法名;参数列表不同：参数个数不同，参数类型不同

```
3 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。`
`4 可变个数形参在方法的形参中，必须声明在末尾`
`5 可变个数形参在方法的形参中,最多只能声明一个可变形参。
```



### `方法应用 3：方法值传递机制的剖析`

#### 2. 针对于方法的参数概念

形参：方法定义时，声明的小括号内的参数。实参：方法调用时，实际传递给形参的数据

递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。

//例6：快排

重写规则

子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写)。

所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；`
`而对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定====”。

#### 1. 属性赋值顺序

总结：属性赋值的先后顺序
① 默认初始化
② 显式初始化
③ 构造器中初始化
④ 通过”对象.方法” 或 “对象.属性”的方式，赋值
以上操作的先后顺序：①- **②-③** -④

②一个无参的公共的构造器（反射造对象用）

#### 4.成员内部类：

 4.1如何创建成员内部类的对象？(静态的，非静态的)
创建`静态`的Dog内部类的实例(静态的成员内部类):
Person.Dog dog = new Person.Dog();

创建非静态的Bird内部类的实例(非静态的成员内部类): Person.Bird bird = new Person.Bird();//错误的，为什么?`
应该用对象去new
`Person p = new Person();`
`Person.Bird bird = p.new Bird();

注意点：
`在局部内部类的方法中（比如：show如果调用局部内部类所声明的方法(比如：method)中的局部变量(比如：num)的话,要求此局部变量声明为final的。`

- jdk 7及之前版本：要求此局部变量显式的声明为final的
  `jdk 8及之后的版本：可以省略final的声明`
  总结：
  成员内部类和局部内部类，在编译以后，都会生成字节码文件。
  `格式：成员内部类：外部类$内部类名.class`
  `局部内部类：外部类$数字 内部类名.class`

---------------

### 6

如果方法的形参和类的属性同名时，我们必须显式的使用"this.变量"的方式，表明此变量是属性，而非形参。

如果构造器的形参和类的属性同名时，我们必须显式的使用"this.变量"的方式，表明此变量是属性，而非形参。

规定："this(形参列表)"必须声明在当前构造器的首行

import:导入

2.5 如果使用的类或接口是java.lang包下定义的，则可以省略import结构。

2.6 如果使用的类或接口是本包下定义的，则可以省略import结构。

2.7 如果在源文件中，使用了不同包下的同名的类，则必须至少一个类需要以全类名的方式示。

2.8 使用"xxx.xx"方式表明可以调用xxx包下的所结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入(xx表示类或接口)。
2.9 import空格static:导入指定类或接口中的静态结构:属性或方法。

我们在类的构造器中，`针对于"this(形参列表)"或"super(形参列表)"只能二一，不能同时出现`

### `关键字 static 修饰属性、方法`

 ③ 由于类只会加载一次，则`静态变量在内存中也只会存在一份：存在方法区的静态域中。`

#### 3.静态变量内存解析：

[![image.png](http://cdn.this0.com/blog/img/1678276130698-3bdabf1e-aae7-4835-aac4-18aae960381d.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=VWjWPbaULlafdVHUq6e6xTME/D4=&x-oss-process=style/cdn.this0)](http://cdn.this0.com/blog/img/1678276130698-3bdabf1e-aae7-4835-aac4-18aae960381d.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=VWjWPbaULlafdVHUq6e6xTME/D4=&x-oss-process=style/cdn.this0)xxxxxxxxxx jdk6及之前，存放在方法区。jdk7及之后，存放在堆空间

#### 5.static的注意点：

##### 5.1 在静态的方法内，不能使用this关键字、super关键字

##### 5.2 关于静态属性和静态方法的使用，大家都从生命周期的角度去理解。

final：最终的

#### 1.可以用来修饰：类、方法、变量

- ```
        static final 用来修饰属性：全局常量
  ```

  

在堆空间中，就会加载所有父类中声明的属性。

当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，...直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中父类中的结构，子类对象才可以考虑进行调用。

[![image.png](http://cdn.this0.com/blog/img/1677380277622-696b5a5e-2a9c-4e0f-8921-6b25c5cbcbc9.png)

虽然创建子类对象时，也调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象(没new不算创建对象)。

[![image.png](http://cdn.this0.com/blog/img/1677380288134-808320bd-9ba7-42bf-af5c-5f2b34d16e5b.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=2VseUyoWbYqa3BVfGgxx491/RIY=&x-oss-process=style/cdn.this0)](http://cdn.this0.com/blog/img/1677380288134-808320bd-9ba7-42bf-af5c-5f2b34d16e5b.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=2VseUyoWbYqa3BVfGgxx491/RIY=&x-oss-process=style/cdn.this0)

### ` Object 类及 clone()、finalize()的理解`

像String、Date、File、包装类等都重写了Object类中的equals()方法。

-----------

### 7

体现三：单例模式（将构造器私有化）

static \ final \ abstract \native 可以用来修饰方法

#### 3 .权限修饰符可用来修饰的结构说明：

四种权限都可以用来修饰类的内部结构：属性、方法、`构造器、内部类`
`修饰类的话，只能使用：缺省、public`

子类继承父类以后，仍然认为获取了父类中私的结构。只因为封装性的影响，使得子类不能直接调用父类的结构而已。

3.多态性的使用：`虚拟方法调用`

对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）

子类中定义了与父类同名同参数的方法，`在多态情况下，将此时父类的方法称为虚拟方法，`父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。

#### 1.关于向上转型与向下转型：

##### 1.1 向上转型：多态(`调用父类的方法`)

#### 2.向下转型(`调用子类的方法`)：

如何才能调用子类特的属性和方法？使用向下转型。

[![image.png](http://cdn.this0.com/blog/img/1677510703246-5dc5f55d-b1c5-45f3-93d9-2bd0e831b02f.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=H7RzYi3/KnumfDvvupT4F5mr3Ao=&x-oss-process=style/cdn.this0)](http://cdn.this0.com/blog/img/1677510703246-5dc5f55d-b1c5-45f3-93d9-2bd0e831b02f.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=H7RzYi3/KnumfDvvupT4F5mr3Ao=&x-oss-process=style/cdn.this0)

#### 3.多态性的理解：

① 实现代码的通用性。`
② Object类中定义的public boolean equals(Object obj){ }
JDBC:使用java程序操作(获取数据库连接、CRUD)数据库(MySQL、Oracle、DB2、SQL Server)
`③ 抽象类、接口的使用肯定体现了多态性。（抽象类、接口不能实例化）

④`作用总结：由于虚拟方法调用，能增加程序拓展性。`

----

### 8

- `抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程）`

#### 3.注意点：

##### 3.1.`abstract不能用来修饰：属性、构造器等结构`

##### 3.2.`abstract不能用来修饰私有方法、静态方法、final的方法、final的类`

### `2.面向对象(高级)-模板方法设计模式(//TODO)`

###### 1.2.1 JDK7及以前：只能定义全局常量和抽象方法

```
         >全局常量：public static final的.但是书写时，可以省略不写
         >抽象方法：public abstract的


     1.3.2 JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法（略）
```

##### 1.6. `接口与接口之间可以继承，而且可以多继承`

### `4面向对象(高级)-JDK8 和 JDK9 中接口的新特性`

知识点1：接口中定义的静态方法，只能通过接口来调用。

知识点2：通过实现类的对象，可以调用接口中的默认方法。

知识点3：`如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没重写此方法的情况下，默认调用的是父类中的同名同参数的方法。-->类优先原则`

1.3如果枚举类中只一个对象，则可以作为单例模式的实现方式。

#### 4.使用enum定义枚举类之后，枚举类常用方法：（继承于java.lang.Enum类）

Season1 summer = Season1.SUMMER;
`toString():返回枚举类对象的名称`
System.out.println(summer.toString());
System.out.println(Season1.class.getSuperclass());
System.out.println(“***\**\*\*\*\*\*\*\*\*\*\*\*“);
`values():返回所有的枚举类对象构成的数组`
Season1[] values = Season1.values();
for(int i = 0;i < values.length;i++){
System.out.println(values[i]);
}
System.out.println(“\*\*\*\*\*\*\*\*\*\*\*\*\****“);
Thread.State[] values1 = Thread.State.values();
for (int i = 0; i < values1.length; i++) {
System.out.println(values1[i]);
}

```
//valueOf(String objName):返回枚举类中对象名是objName的对象。
```



#### 1.注解的理解

```
①Jdk 5.0 新增的功能
```

用来配置应用程序的任何`切面`，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。
框架 = 注解 + 反射机制 + 设计模式

@Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。

#### `如何自定义注解`

 `//TODO要结合反射，先感受一下`

如果注解有成员，在使用注解时，需要指明成员的值。`
`自定义注解必须配上注解的信息处理流程(使用反射)才意义。`
自定义注解通过都会`指明两个元注解：Retention、Target

—>类比：`元数据`的概念：String name = “Tom”;

#### `如何获取注解信息:通过发射来进行获取、调用。`

#### 5.`JDK8中注解的新特性：可重复注解、类型注解`

##### 5.1 `可重复注解：`

```
JAVA
import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME)
public @interface Authors {
    Author[] value();
}
------------------------------------------------

    @Author(name = "Alice")
    @Author(name = "Bob")
    public class MyClass {
        // ...
    }
```

##### 5.2 `类型注解：`

ElementType.TYPE_PARAMETER 表示该注解能写在什么类型变量的声明语句中（如：泛型声明。

ElementType.TYPE_USE 表示该注解能写在任何使用类型的语句中。

单元测试。
此时的Java类要求：① 此类是public的 ②此类提供公共的无参的构造器`(只能有一个？)`
`如果测试类需要进行依赖注入等复杂操作，则可以使用带参数的构造函数，并在测试方法上使用注解来指定运行器应该使用哪个构造函数进行实例化。例如，使用JUnit 4框架时，可以使用@RunWith(Parameterized.class)注解来指定带参数的构造函数。`

此时的单元测试方法：`方法的权限是public,没返回值，没形参`

① Vector类中关于添加元素，只定义了形参为Object类型的方法：`
`v.addElement(Object obj); //基本数据类型 --->包装类 --->使用多态

-----

### 9

像数据库连接、输入输出流、网络编程Socket等资源，`JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。`

#### 5.[面试题]

```
final、finally、finalize三者的区别？
```

throw 和 throws`
`Collection 和 Collections`
`String 、StringBuffer、StringBuilder ArrayList 、 LinkedList HashMap 、LinkedHashMap

throws的方式只是将异常抛给了方法的调用者。并没真正将异常处理掉。

#### 3.体会开发中应该如何选择两种处理方式？

3.1 如果父类中被重写的方法没throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中异常，必须使用try-catch-finally方式处理。`
3.2 执行的方法a中，先后又调用了另外的几个方法，`这几个方法是递进关系执行的。我们建议这几个方法使用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理。

throw `表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内。`

### 5.异常处理-如何自定义异常类及课后练习

如何自定义异常类？

#### 1.继承于现的异常结构：RuntimeException 、Exception

#### 2.`提供全局常量：serialVersionUID (IO流的时候再说)`

#### 3.`通常提供几个重载的构造器`

---------

### 10 多线程

进程作为资源分配的单位

线程作为调度和执行的单位，每个线程拥独立的运行栈和程序计数器(pc)

[![image.png](http://cdn.this0.com/blog/img/1679048419813-b28672a1-cc30-4215-800f-ee6e6fe37250.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=tgtCgFdLr0aHZcWj7fJQsdI4Qac=&x-oss-process=style/cdn.this0)](http://cdn.this0.com/blog/img/1679048419813-b28672a1-cc30-4215-800f-ee6e6fe37250.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=tgtCgFdLr0aHZcWj7fJQsdI4Qac=&x-oss-process=style/cdn.this0)

每个线程，拥有自己`独立的：栈、程序计数器`
多个线程，`共享同一个进程中的结构：方法区、堆。`

问题一：我们启动一个线程，必须调用start()，不能调用run()的方式启动线程。`为什么？`

两种方式的对比：
开发中,优先选择：实现Runnable接口的方式
原因：

1. 实现的方式没类的单继承性的局限性(无法继承其他的)

2. 实现的方式更适合来处理`多个线程共享数据`的情况`（接口实现类天然能共享对象）`。

   

6 `yield():释放当前cpu的执行权`

7 `join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。`

8 `stop():已过时。`当执行此方法时，强制结束当前线程。

 1.`常见线程优先级`
 MAX_PRIORITY：10
 MIN _PRIORITY：1
 NORM_PRIORITY：5 –>默认优先级

 2.`如何获取和设置当前线程的优先级：`
 getPriority():获取线程的优先级
 setPriority(int p):设置线程的优先级
 `notify() / notifyAll()唤醒`

说明：`高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只当高优先级的线程执行完以后，低优先级的线程才执行。`

新建，runable，死亡`//TODO,这两行好像没弄对
`runable又可以分为3种，无限等待，有限等待，锁阻塞

线程通信：wait() / notify() / notifyAll() :此三个方法定义在Object类中的。

 `多个线程必须要共用同一把锁。`
补充：在`实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。`
`在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。`

##### 2.2 方式二：同步方法

###### 2.2.1概述

如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。
关于同步方法的总结：
①`同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。`
`②非静态的同步方法，同步监视器是：this`
`③ 静态的同步方法，同步监视器是：当前类本身`

操作同步代码时，只能一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。

### `7.多线程-线程安全的懒汉式死锁_ReentrantLock 的使用`

##### 1.1面试题：synchronized 与 Lock的异同？

相同：二者都可以解决线程安全问题
不同：`synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器 Lock需要手动的启动同步（lock()，同时结束同步也需要手动的实现（unlock()）`

```
为什么这个顺序
```

Lock —> 同步代码块（已经进入了方法体，分配了相应资源 ) —>同步方法（在方法体之外)

1.2.notify():一旦执行此方法，就会`唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。`

2.1.wait()，notify()，notifyAll()三个方法必须使用`在同步代码块或同步方法中。`
2.2.wait()，notify()，notifyAll()`三个方法的调用者必须是同步代码块或同步方法中的同步监视器。`否则，会出现IllegalMonitorStateException异常
2.3.wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。

#### 3.面试题：

面试题：`sleep() 和 wait()的异同？`
3.1.相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。
3.2.不同点：
①两个方法声明的位置不同：`Thread类中声明sleep() （静态的） , Object类中声明wait()`
②调用的要求不同：`sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中`
③关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，`sleep()不会释放锁，wait()会释放锁。`

#### 1.`新增方式一：实现Callable接口。 --- JDK 5.0新增`

//TODO没记住

#### 2.新增方式二：`使用线程池(TODO)`

//TODO,下面的NumberThread 和NumberThread 1里面，应该有一个是继承线程类的，没改，存疑

//TODO这里不是重复了吗？应该是有一个是继承Thread类，暂时没改

----------

### 11 常用类与基础API

String内部定义了final char[] value用于存储字符串数据 `（jdk9开始变byte【】了）`

[![image.png](http://cdn.this0.com/blog/img/1679079790946-8c247823-7c7b-4a04-b3e2-167254fc3a82.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=VbqnDFcF4AMBb62T90BcYxXIJdA=&x-oss-process=style/cdn.this0)](http://cdn.this0.com/blog/img/1679079790946-8c247823-7c7b-4a04-b3e2-167254fc3a82.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=VbqnDFcF4AMBb62T90BcYxXIJdA=&x-oss-process=style/cdn.this0)

String s = new String(“abc”);方式创建对象，在内存中`创建了几个对象？`
`两个:一个是堆空间中new结构，另一个是char[]对应的常量池中的数据："abc"`

[![image.png](http://cdn.this0.com/blog/img/1679083737985-dc80c79a-5403-40ef-9161-2b25d517e465.png)

 5.1.3.`intern()方法返回的是字符串常量池中字面量的地址`

`String trim()`：返回字符串的副本，忽略前导空白和尾部空白

String concat(String str)：将指定字符串连接到此字符串的结尾。 等价于用“+”`
`int compareTo(String anotherString)：比较两个字符串的大小

boolean `startsWith(String prefix)：测试此字符串是否以指定的前缀开始`

boolean `contains(CharSequence s)：当且仅当此字符串包含指定的 char 值序列时，返回 true`
int `indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引`

String `replace(CharSequence target, CharSequence replacement)`：使用指定的字面值替换序列替换此字符串所匹配字面值目标序列的子字符串。
String `replaceAll(String regex, String replacement)：使用给定的 replacement 替换此字符`串所匹配给定的正则表达式的子字符串。

boolean matches(String regex)：告知此字符串是否匹配给定的`正则表达式`。

### `4.常用类与基础 API-StringBuffer 与 StringBuilder 的源码分析、常用方法`

####  

String:不可变的字符序列；底层使用char[]存储，`线程安全不？`

#### 5.与StringBuffer、StringBuilder之间的转换

String –>StringBuffer、StringBuilder:调用StringBuffer、StringBuilder构造器
`StringBuffer、StringBuilder -->String:①调用String构造器；②StringBuffer、StringBuilder的toString()`

[![image.png](http://cdn.this0.com/blog/img/1679208080231-2971c9d0-79dd-4557-8047-be64332a8ab4.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=8KWa2tTqPEQ0pUTYsh7ZwITQ7XY=&x-oss-process=style/cdn.this0)](http://cdn.this0.com/blog/img/1679208080231-2971c9d0-79dd-4557-8047-be64332a8ab4.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=8KWa2tTqPEQ0pUTYsh7ZwITQ7XY=&x-oss-process=style/cdn.this0)

#### 日期时间格式化类：`DateTimeFormatter`



DateTimeFormatter formatter3 = DateTimeFormatter.ofPattern("yyyy-MM-dd hh:mm:ss"); 格式化 String str4 = formatter3.format(LocalDateTime.now()); System.out.println(str4);//2019-02-18 03:52:09 解析 TemporalAccessor accessor = formatter3.parse("2019-02-18 03:52:09"); System.out.println(accessor);

### `常用类与基础 API-使用 Comparable 接口实现自然排序`

实现了Comparable接口，重写了compareTo(obj)方法

#### 1.定制排序：使用Comparator接口

##### 1.1 说明

###### 1.1.1.背景：

当元素的类型没实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑`使用 Comparator` 的对象来排序

**.**`重写compare(Object o1,Object o2)`**方法，比较o1和o2的大小：**

Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小。
`Comparator接口//TODO是接口吗`属于临时性的比较。

#### 3.BigInteger类、BigDecimal类

说明：
`① java.math包的BigInteger可以表示不可变的任意精度的整数。`

```
② 要求数字精度比较高的浮点数，用到java.math.BigDecimal类
```

-----------

### 12 集合框架

#### 5.概览

|—-Collection接口：单列集合，用来存储一个一个的对象
|—-List接口：存储有序的、可重复的数据。 –>“动态”数组
`|----ArrayList、LinkedList、Vector`
|—-Set接口：存储无序的、不可重复的数据 –>高中讲的“集合”
|—-HashSet、LinkedHashSet、TreeSet
java.util.Map:存储一对一对的数据
|—-Ｍａｐ接口：存储无序的、不可重复的数据 –>高中讲的“集合” //TODO感觉不对。
|—-HashMap、LinkedHashMap、TreeMap,Hashtable,Properties

[![image.png](http://cdn.this0.com/blog/img/1679233826224-ef45eb1c-77dd-41f9-aba1-924b5169e8b4.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000001&Signature=FfJkfz0dtskqUdtBSto7fp/Z6z4=&x-oss-process=style/cdn.this0)](https://yuling-1318764606.cos.ap-chengdu.myqcloud.com/blog/1679233826224-ef45eb1c-77dd-41f9-aba1-924b5169e8b4.png)

#### 2.Collection接口常用方法：

addAll(Collection coll),

retainsAll(Collection coll), //求两个集合的交集

#### Collection集合与数组间的转换

coll.toArray();

s.`asList(new String[]{"AA", "BB", "CC"});`

向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals(). （ 因为collection中的相关方法contains（）/remove()需要重写,//TODO，为什么）

#### `5.增强for循环`

②不同的集合类底层的数据结构为何？

#### `3.集合框架-List 接口常用方法的测试`

常用方法：(记住)
增：add(Object obj)
删：remove(int index) / remove(Object obj)
`改：set(int index, Object ele) 查：get(int index)`
`插：add(int index, Object ele)`
长度：size()
遍历：① Iterator迭代器方式
② 增强for循环
③ 普通的循环

//TODO，补一个迭代器和增强for循环

#### `4.集合框架-List 不同实现类的对比及课后练习`

 |—-ArrayList：作为List接口的主要实现类；线程不安全的，效率高,`遇到线程安全问题用collection自己包一下`
​ |—-`LinkedList：对于频繁的插入、删除操作`，使用此类效率比ArrayList高；底层使用双向链表存储
​ |—-Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储 `彻底失宠，已经不用了`

[面试题]
面试题：ArrayList、LinkedList、Vector者的异同？
同：三个类都是实现了List接口，存储数据的特点相同：存储序的、可重复的数据
不同：`见上（第3部分+第4部分）//TODO`

#### `5.集合框架-Set 不同实现类的对比及 Set 无序性、不可重复性的剖析`

#### 1.存储的数据特点：无序的、不可重复的元素

 以HashSet为例说明：

##### 1.1`无序性：不等于随机性。存储的数据在底层数组中并非照数组索引的顺序添加，而是根据数据的哈希值决定的。`

##### 1.2不可重复性：保证添加的元素按照equals()判断时，不能返回true.即：相同的元素只能添加一个。

#### 2.元素添加过程：(以HashSet为例)`（老版顺序，先不看）`

jdk 7 :元素a放到数组中，指向原来的元素。 jdk 8 :原来的元素在数组中，指向元素a

#### 3.常用实现类：

 |—-Set接口：存储无序的、不可重复的数据 –>高中讲的“集合”
​ |—-HashSet：作为Set接口的主要实现类；底层用HashMap，即使用`数组+单向链表+红黑树结构进行存储，`
​ |—-LinkedHashSet：作为HashSet的子类；在现有基础上，又添加了一组双向链表，用于记录添加元素的先后顺序
​ `|----TreeSet：底层用红黑树存储，可以按照添加的元素的指定的属性的大小顺序进行遍历`

#### 5.set中无序性，不可重复性的理解的要求：

5.1.无序性：！=随机性
添加元素的顺序和遍历元素的顺序不一致，是不是就是无序性呢？no！
什么是无序性？与添加的元素的位置有关，不像ArrayList一样是一次`紧密排列`的。
这里是根据添加的元素的哈希值，计算的其在数组中的存储位置。此位置不是依次排列的，表现为无序性`（LinkedHashSet也是无序，不过用了链表指向顺序）`
5.2.不可重复性：添加到Set的元素是不能相同的，比较的标准，需要判断hashCode()得到的哈希值、equals()得到的boolean型结果，`哈希值相同且equals()返回true，则认为元素是相同的。`

#### 6.添加到`hashset/linkedhashset`中元素的要求：

 要求元素所在的类`要重写两个方法: equals()和hashCode()。`
​ 同时，`要求equals()和 hashCode()要保持一致性!`我们只需要在IDEA中自动生成两个方法的重写即可，即能保证

#### `6.集合框架-TreeSet 的使用与 Set 接口课后练习`

#### 1.向TreeSet中添加的元素的要求

 `要求是相同类型的对象，否则报异常。`

#### `7.集合框架-Map不同实现类的对比与 HashMap 中元素的特点`

#### 1.常用实现类结构

|—-Map:双列数据，存储key-value对的数据 —类似于高中的函数：y = f(x)
|—-HashMap:作为Map的主要实现类；`线程不安全的`，效率高；`能存储null的key和value`
|—-LinkedHashMap:保证在遍历map元素时，可以照添加的顺序实现遍历。
|—-Hashtable:`作为古老的实现类；线程安全的，效率低；不能存储null的key和value`
|—-TreeMap:保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序，底层使用红黑树
|—-Properties:常用来处理配置文件。key和value都是String类型
`HashMap的底层：数组+链表 （jdk7及之前) 数组+链表+红黑树 （jdk 8)`

#### 2.存储结构的理解：

Map中的key:无序的、不可重复的，使用Set存储所有的key —> `key所在的类要重写equals()和hashCode() （以HashMap为例)`，//TODO为什么啊
Map中的value:无序的、可重复的，使用Collection存储所的value —>`value所在的类要重写equals()`//TODO为什么啊
一个键值对：key-value构成了一个Entry对象。
Map中的entry:无序的、不可重复的，使用Set存储所有的entry

//TODOset常用方法有哪些

`添加：put(Object key,Object value)`
删除：remove(Object key)
修改：put(Object key,Object value)
查询：get(Object key)
长度：size()
遍历：keySet() / values() / entrySet()

#### 1.TreeMap的使用

向TreeMap中添加key-value，要求`key必须是由同一个类创建的对象因为要照key进行排序：自然排序 、定制排序`

Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素`
Object min(Collection)
`Object min(Collection，Comparator)`
`int frequency(Collection，Object)：返回指定集合中指定元素的出现次数

使用synchronizedList(List list） 和 synchronizedMap(Map map）

#### 3.面试题：

面试题：Collection 和 Collections的区别？

-------------

### 13 泛型

泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没任何关系。`
`换句话说，泛型方法所属的类是不是泛型类都没关系。`
`泛型方法，可以声明为静态的。原因：泛型参数是在调用方法时确定的。并非在实例化类时确定。

//TODO，哪种是泛型方法和泛型类？

由于子类在继承带泛型的父类时，指明了泛型类型。则实例化子类对象时，不再需要指明泛型。

2.2. `泛型类的构造器`如下: public GenericClass(){}。
而下面是错误的: public GenericClass(){}

泛型对应的类型均按照Object处理，但不等价 于Object。

如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。

2.9.`在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的泛型。`

参考: `ArrayList源码中声明: Object elementData,而非泛型参数类型数组。`
2.12.父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型:
`●子类不保留父类的泛型:按需实现 ➢没有类型擦除 ➢具体类型 ●子类保留父类的泛型:泛型子类 ➢全部保留 ➢部分保留 结论:子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自 己的泛型`

### `3.泛型-泛型在继承上的体现及通配符的使用`

A是类B的父类，但是G<A> 和G<B>二者不具备子父类关系，二者是并列关系。通配符章节会出现他们的父类

此时的list1和list2的类型不具子父类关系

通配符：? 类A是类B的父类，G<A>和G<B>是没关系的，二者共同的父类是：G<?>

 `添加(写入)：对于List<?>不能直接向其内部添加数据。 //（因为里面类型不确定）除了添加null之外，直到确定泛型类型`

获取(读取)：泛型允许读取数据，读取的数据类型为Object （因为通配符不知道具体类型，就当object了）。//TODO这个代码要补充

? extends A:
G<? extends A> 可以作为G<A>和G<B>**的子类，其中B是A的子类
? super A:
`G<? super A> 可以作为G<A>和G<B>的父类，其中B是A的父类`**
