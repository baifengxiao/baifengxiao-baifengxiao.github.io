---
title: JavaSE干货
tags:
  - 学而时习之
  - JavaSE
categories:
  - 学而时习之
abbrlink: b7352c4c
date: '2024-01-12 02:21:01'
description: JavaSE干货
---

### 1 √

#### **标识符的命名规范**

1.包名：多单词组成时所有字母都小写：xxxyyyzzz
2.类名、接口名：多单词组成时，**所有单词的首字母大写**：XxxYyyZzz
3.变量名、方法名：多单词组成时，**第一个单词首字母小写，第二个单词开始每个单词首字母大写**：xxxYyyZzz
4.常量名：所有字母都大写。**多单词时每个单词用下划线连接**：XXX_YYY_ZZZ

#### java采用unicode字符集

#### **变量的作用:用于在内存中保存数据**

#### 变量的使用注意事项：

1. 变量必须**先声明才能使用**,否则报错：错误: 找不到符号

2. 变量必须**先初始化值**才能使用,否则，错误: 可能尚未初始化变量age

-------

### 2 √

#### 计算机底层存储的是整数的**补码**。

#### **补码：正整数的补码与原码一致，负整数的补码是在反码基础上加1**

#### 浮点型系列精度

float：

**精度：可展示小数点后七位，小数点后六位准确，第七位不准确**

double

**精度：可展示小数点后十六位，小数点后十五位准确，第十六位不准确** 

#### **当byte、char、short三种类型的变量做运算时，结果为int型**

short s1 = 10;
s1 += 2;//结论：`不会改变变量本身的数据类型`

#### **位运算符的运算过程都是基于补码运算，但是看结果，我们得换成原码，再换成十进制看结果**

#### 如何区分&,|,^是逻辑运算符还是位运算符？

**如果操作数是boolean类型，就是逻辑运算符，如果操作数是整数，那么就是位运算符。**

----------

### 3 √

#### 如果if-else结构中的执行语句只有一行时，对应的一对{}可以省略的。

####  witch结构中的表达式，只能是如下的6种数据类型之一： byte 、short、char、int、枚举类型(JDK5.0新增)、String类型(JDK7.0新增)

####  case 之后只能声明常量。

#### //TODO 时间复杂度 、空间复杂度 （衡量算法的好坏）

--------------------

### 4 √

#### `创建数组对象会在内存中开辟一整块连续的空间`

#### char型默认值0或'\u0000'，而非'0'

#### 数组内存解析

![image.png](http://cdn.this0.com/blog/img/1676455218210-a9e3eb93-f232-4837-b110-7fa3baa24633.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000001&Signature=GOV9zW7Oi5fETbTTRIZ052bmnwU=&x-oss-process=style/cdn.this0)

#### 栈里面放地址，局部变量放栈里面 堆空间开辟结构，放地址值（首地址值)

### 二维数组的内存解析

[![image.png](http://cdn.this0.com/blog/img/1676543604055-cf9577ec-5c1e-4048-8dff-696307dce0d3.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=9XHMxkhwjcWUNvwQii6/5A9q2zA=&x-oss-process=style/cdn.this0)](http://cdn.this0.com/blog/img/1676543604055-cf9577ec-5c1e-4048-8dff-696307dce0d3.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000001&Signature=fDrshKLq6OAEAn9VoYxSqZ2ca40=&x-oss-process=style/cdn.this0)

栈里面放地址，局部变量放栈里面 堆空间开辟结构，放地址值（首地址值)

--------------

### 5 √

#### `类的实例化与对象的内存解析`

//TODO

内存解析：
我们使用JVM中的类的加载器和解释器对生成的字节码文件进行解释运行，需要将字节码文件对应的类加载到内存中，涉及到内存解析。

我们将`局部变量存储在栈结构中` 

`堆，我们将new出来的结构（比如：数组、对象）加载在堆空间中。`

补充：对象的属性（非static的)加载在堆空间中。static的呢？

static的属性则加载在方法区

方法区：存放类的加载信息、常量池、静态域

局部变量：没默认初始化值。

#### 2.4 在内存中加载的位置：

属性：加载到堆空间中（非static） 局部变量：加载到栈空间

static、final、abstract来修饰的方法,

return关键字后面不可以声明执行语句。

### 7. `方法的内存解析//TODO`

### 8. `对象数组的使用及内存解析`

#### 1. 方法的重载的概念

定义：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。

两同一不同:同一个类、相同方法名;参数列表不同：参数个数不同，参数类型不同

3 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组不能共存。

4 可变个数形参在方法的形参中，必须声明在末尾

5 可变个数形参在方法的形参中,最多只能声明一个可变形参。

### `方法应用 3：方法值传递机制的剖析`

重写规则

子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写而是隐藏了父类的方法)。

所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；
而对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。

#### 属性赋值顺序

总结：属性赋值的先后顺序
① 默认初始化
② 显式初始化
③ 构造器中初始化
④ 通过”对象.方法” 或 “对象.属性”的方式，赋值
以上操作的先后顺序：①- **②-③** -④

JavaBean一个无参的公共的构造器（反射造对象用）

#### 成员内部类：

如何创建成员内部类的对象？(静态的，非静态的)

创建`静态`的Dog内部类的实例(静态的成员内部类):

这里假设`Dog`是`Person`类的静态成员内部类。

Person.Dog dog = new Person.Dog();

创建非静态的Bird内部类的实例(非静态的成员内部类):

```java
 Person.Bird bird = new Person.Bird();//错误的，为什么?
```

创建非静态成员内部类的实例时，需要理解非静态内部类与外部类实例之间的关系。

在Java中，非静态内部类与外部类的实例是有关联的，因为非静态内部类隐含地包含了对外部类实例的引用。创建非静态的成员内部类的实例时，需要使用外部类的实例来调用内部类的构造函数，建立与外部类的实例相关联，所以应该这样调用：

```java
Person p = new Person();
Person.Bird bird = p.new Bird();
```

`注意点`：

在局部内部类的方法中（比如：show),如果调用局部内部类所声明的方法(比如：method),中的局部变量(比如：num)的话,要求此局部变量声明为final的。

```java
public class OuterClass {
    public void show() {
        // 局部变量 num
        int num = 10;
        // 局部内部类
        class LocalInnerClass {
            public void method() {
                // 在局部内部类的方法中调用外部方法的局部变量
                // 要求该局部变量声明为 final
                System.out.println("Value of num: " + num);
            }
        }

        // 创建局部内部类的实例
        LocalInnerClass innerClass = new LocalInnerClass();
        // 调用局部内部类的方法
        innerClass.method();
    }
}
```

jdk 7及之前版本：要求此局部变量显式的声明为final的
`jdk 8及之后的版本：可以省略final的声明`
总结：
成员内部类和局部内部类，在编译以后，都会生成字节码文件。
`格式：`

`成员内部类：外部类$内部类名.class`

`局部内部类：外部类$数字 内部类名.class`

---------------

### 6

规定："this(形参列表)"必须声明在当前构造器的首行

import:导入

2.7 如果在源文件中，使用了不同包下的同名的类，则必须至少一个类需要以全类名的方式示。

2.8 使用"xxx.xx"方式表明可以调用xxx包下的所结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入(xx表示类或接口)。
2.9 import static:导入指定类或接口中的静态结构:属性或方法。

我们在类的构造器中，`针对于"this(形参列表)"或"super(形参列表)"只能二一，不能同时出现`

### `关键字 static 修饰属性、方法`

 ③ 由于类只会加载一次，则`静态变量在内存中也只会存在一份：存在方法区的静态域中。`

#### 3.静态变量内存解析：

[![image.png](http://cdn.this0.com/blog/img/1678276130698-3bdabf1e-aae7-4835-aac4-18aae960381d.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=VWjWPbaULlafdVHUq6e6xTME/D4=&x-oss-process=style/cdn.this0)](http://cdn.this0.com/blog/img/1678276130698-3bdabf1e-aae7-4835-aac4-18aae960381d.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=VWjWPbaULlafdVHUq6e6xTME/D4=&x-oss-process=style/cdn.this0) `jdk6及之前，存放在方法区。jdk7及之后，存放在堆空间`

#### 5.static的注意点：

##### 5.2 关于静态属性和静态方法的使用，大家都从生命周期的角度去理解。

​    static final 用来修饰属性：全局常量

`在堆空间中，就会加载所有父类中声明的属性。`

虽然创建子类对象时，也调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象(没new不算创建对象)。

[![image.png](http://cdn.this0.com/blog/img/1677380288134-808320bd-9ba7-42bf-af5c-5f2b34d16e5b.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=2VseUyoWbYqa3BVfGgxx491/RIY=&x-oss-process=style/cdn.this0)](http://cdn.this0.com/blog/img/1677380288134-808320bd-9ba7-42bf-af5c-5f2b34d16e5b.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=2VseUyoWbYqa3BVfGgxx491/RIY=&x-oss-process=style/cdn.this0)

### ` Object 类finalize()`

   finalize():当垃圾收集器准备回收一个对象时，它会首先调用该对象的 finalize() 方法。这个方法的默认实现是空的，但你可以在你自己的类中覆盖这个方法，以便在对象被销毁前执行一些必要的清理工作，比如关闭文件、释放资源等。

-----------

### 7

体现三：单例模式（将构造器私有化）

static \ final \ abstract \native 可以用来修饰方法

当一个方法被声明为`native` 时，它的实现体并不在Java代码中，而是由本地的原生代码提供。这样的方法被称为本地方法（Native Method）。

#### 3 .权限修饰符可用来修饰的结构说明：

四种权限都可以用来修饰类的内部结构：属性、方法、`构造器、内部类`.....
`修饰类的话，只能使用：缺省、public`

3.多态性的使用：`虚拟方法调用`

子类中定义了与父类同名同参数的方法，`在多态情况下，将此时父类的方法称为虚拟方法，`父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。

#### 1.关于向上转型与向下转型：

##### 1 向上转型：多态(`调用父类的方法`)

##### 2.向下转型(强转，`调用子类的方法`)：

如何才能调用子类特的属性和方法？使用向下转型。

[![image.png](http://cdn.this0.com/blog/img/1677510703246-5dc5f55d-b1c5-45f3-93d9-2bd0e831b02f.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=H7RzYi3/KnumfDvvupT4F5mr3Ao=&x-oss-process=style/cdn.this0)](http://cdn.this0.com/blog/img/1677510703246-5dc5f55d-b1c5-45f3-93d9-2bd0e831b02f.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=H7RzYi3/KnumfDvvupT4F5mr3Ao=&x-oss-process=style/cdn.this0)

#### 3.多态性的理解：

① 实现代码的通用性。

③ 抽象类、接口的使用肯定体现了多态性。（抽象类、接口不能实例化）

④`作用总结：由于虚拟方法调用，能增加程序拓展性。`

----

### 8

抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程）`

### `模板方法设计模式(//TODO)`

###### 1.2.1 JDK7及以前：只能定义全局常量和抽象方法

全局常量：public static final的.但是书写时，可以省略不写
抽象方法：public abstract的,可以省略不写

 JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法（略）

##### 1.6. `接口与接口之间可以继承，而且可以多继承`

### `JDK8 和 JDK9 中接口的新特性`

知识点1：接口中定义的`静态方法，只能通过接口来调用`。

知识点3：`如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没重写此方法的情况下，默认调用的是父类中的同名同参数的方法。-->类优先原则`

如果枚举类中只一个对象，则可以作为单例模式的实现方式。

#### 4.使用enum定义枚举类之后，枚举类常用方法：（继承于java.lang.Enum类）

#### 1.注解的理解

用来配置应用程序的任何`切面`，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。

框架 = 注解 + 反射机制 + 设计模式

@Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。

#### `如何自定义注解`

 `//TODO要结合反射，先感受一下`

#### 5.`JDK8中注解的新特性：可重复注解、类型注解`

##### 5.1 `可重复注解：`

##### 5.2 `类型注解：`

单元测试的Java类要求：

① 此类是public的

②此类提供公共的无参的构造器`(只能有一个？)`
`如果测试类需要进行依赖注入等复杂操作，则可以使用带参数的构造函数，并在测试方法上使用注解来指定运行器应该使用哪个构造函数进行实例化。`

`例如，使用JUnit 4框架时，可以使用@RunWith(Parameterized.class)注解来指定带参数的构造函数。`

此时的单元测试方法：`方法的权限是public,没返回值，没形参`

-----

### 9

像数据库连接、输入输出流、网络编程Socket等资源，`JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。`

#### 5.[面试题]

Collection 和 Collections

 HashMap 、LinkedHashMap

#### 3.体会开发中应该如何选择两种处理方式？

### 5.异常处理-如何自定义异常类及课后练习

如何自定义异常类？

---------

### 10 多线程

进程作为资源分配的单位

线程作为调度和执行的单位

[![image.png](http://cdn.this0.com/blog/img/1679048419813-b28672a1-cc30-4215-800f-ee6e6fe37250.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=tgtCgFdLr0aHZcWj7fJQsdI4Qac=&x-oss-process=style/cdn.this0)](http://cdn.this0.com/blog/img/1679048419813-b28672a1-cc30-4215-800f-ee6e6fe37250.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=tgtCgFdLr0aHZcWj7fJQsdI4Qac=&x-oss-process=style/cdn.this0)

每个线程，拥有自己`独立的：栈、程序计数器`
多个线程，`共享同一个进程中的结构：方法区、堆。`

问题一：我们启动一个线程，必须调用start()，不能调用run()的方式启动线程。`为什么？`

使用`start()`方法才会启动一个新的线程并在后台运行，使得线程能够并发执行。

6 `yield():释放当前cpu的执行权`

7 `join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。`

8 `stop():已过时。`当执行此方法时，强制结束当前线程。替换为interrupt()

 1.`常见线程优先级`
 MAX_PRIORITY：10
 MIN _PRIORITY：1
 NORM_PRIORITY：5 –>默认优先级

 2.`如何获取和设置当前线程的优先级：`
 getPriority():获取线程的优先级
 setPriority(int p):设置线程的优先级
 `notify() / notifyAll()唤醒`

说明：`高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只当高优先级的线程执行完以后，低优先级的线程才执行。`

新建，runable，死亡`//TODO,这两行好像没弄对，后面有提到`，完整的

runable又可以分为3种，无限等待，有限等待，锁阻塞

线程通信：wait() / notify() / notifyAll() :此三个方法定义在Object类中的。

notify() ：哪个线程被唤醒是不确定的，取决于线程调度器的策略。
补充：

# 没看懂

在`实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。`
`在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。`

##### 2.2 方式二：同步方法

###### 2.2.1概述

如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。
关于同步方法的总结：
①`同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。`
`②非静态的同步方法，同步监视器是：this`
`③ 静态的同步方法，同步监视器是：当前类本身`

操作同步代码时，只能一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。

### `7.多线程-线程安全的懒汉式死锁_ReentrantLock 的使用`

##### 1.1面试题：synchronized 与 Lock的异同？

相同：二者都可以解决线程安全问题
不同：`synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器 Lock需要手动的启动同步（lock()，同时结束同步也需要手动的实现（unlock()）`

```
为什么这个顺序
```

Lock —> 同步代码块（已经进入了方法体，分配了相应资源 ) —>同步方法（在方法体之外)

1.2.notify():一旦执行此方法，就会`唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。`

2.1.wait()，notify()，notifyAll()三个方法必须使用`在同步代码块或同步方法中。`
2.2.wait()，notify()，notifyAll()`三个方法的调用者必须是同步代码块或同步方法中的同步监视器。`否则，会出现IllegalMonitorStateException异常
2.3.wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。

#### 3.面试题：

面试题：`sleep() 和 wait()的异同？`
3.1.相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。
3.2.不同点：
①两个方法声明的位置不同：`Thread类中声明sleep() （静态的） , Object类中声明wait()`
②调用的要求不同：`sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中`
③关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，`sleep()不会释放锁，wait()会释放锁。`

#### 1.`新增方式一：实现Callable接口。 --- JDK 5.0新增`

//TODO没记住

#### 2.新增方式二：`使用线程池(TODO)`

//TODO,下面的NumberThread 和NumberThread 1里面，应该有一个是继承线程类的，没改，存疑

//TODO这里不是重复了吗？应该是有一个是继承Thread类，暂时没改

----------

### 11 常用类与基础API

String内部定义了final char[] value用于存储字符串数据 `（jdk9开始变byte【】了）`

[![image.png](http://cdn.this0.com/blog/img/1679079790946-8c247823-7c7b-4a04-b3e2-167254fc3a82.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=VbqnDFcF4AMBb62T90BcYxXIJdA=&x-oss-process=style/cdn.this0)](http://cdn.this0.com/blog/img/1679079790946-8c247823-7c7b-4a04-b3e2-167254fc3a82.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=VbqnDFcF4AMBb62T90BcYxXIJdA=&x-oss-process=style/cdn.this0)

String s = new String(“abc”);方式创建对象，在内存中`创建了几个对象？`
`两个:一个是堆空间中new结构，另一个是char[]对应的常量池中的数据："abc"`

[![image.png](http://cdn.this0.com/blog/img/1679083737985-dc80c79a-5403-40ef-9161-2b25d517e465.png)

 5.1.3.`intern()方法返回的是字符串常量池中字面量的地址`

`String trim()`：返回字符串的副本，忽略前导空白和尾部空白

String concat(String str)：将指定字符串连接到此字符串的结尾。 等价于用“+”`
`int compareTo(String anotherString)：比较两个字符串的大小

boolean `startsWith(String prefix)：测试此字符串是否以指定的前缀开始`

boolean `contains(CharSequence s)：当且仅当此字符串包含指定的 char 值序列时，返回 true`
int `indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引`

String `replace(CharSequence target, CharSequence replacement)`：使用指定的字面值替换序列替换此字符串所匹配字面值目标序列的子字符串。
String `replaceAll(String regex, String replacement)：使用给定的 replacement 替换此字符`串所匹配给定的正则表达式的子字符串。

boolean matches(String regex)：告知此字符串是否匹配给定的`正则表达式`。

### `4.常用类与基础 API-StringBuffer 与 StringBuilder 的源码分析、常用方法`

####  

String:不可变的字符序列；底层使用char[]存储，`线程安全不？`

#### 5.与StringBuffer、StringBuilder之间的转换

String –>StringBuffer、StringBuilder:调用StringBuffer、StringBuilder构造器
`StringBuffer、StringBuilder -->String:①调用String构造器；②StringBuffer、StringBuilder的toString()`

[![image.png](http://cdn.this0.com/blog/img/1679208080231-2971c9d0-79dd-4557-8047-be64332a8ab4.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=8KWa2tTqPEQ0pUTYsh7ZwITQ7XY=&x-oss-process=style/cdn.this0)](http://cdn.this0.com/blog/img/1679208080231-2971c9d0-79dd-4557-8047-be64332a8ab4.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=8KWa2tTqPEQ0pUTYsh7ZwITQ7XY=&x-oss-process=style/cdn.this0)

#### 日期时间格式化类：`DateTimeFormatter`



DateTimeFormatter formatter3 = DateTimeFormatter.ofPattern("yyyy-MM-dd hh:mm:ss"); 格式化 String str4 = formatter3.format(LocalDateTime.now()); System.out.println(str4);//2019-02-18 03:52:09 解析 TemporalAccessor accessor = formatter3.parse("2019-02-18 03:52:09"); System.out.println(accessor);

### `常用类与基础 API-使用 Comparable 接口实现自然排序`

实现了Comparable接口，重写了compareTo(obj)方法

#### 1.定制排序：使用Comparator接口

##### 1.1 说明

###### 1.1.1.背景：

当元素的类型没实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑`使用 Comparator` 的对象来排序

**.**`重写compare(Object o1,Object o2)`**方法，比较o1和o2的大小：**

Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小。
`Comparator接口//TODO是接口吗`属于临时性的比较。

#### 3.BigInteger类、BigDecimal类

说明：
`① java.math包的BigInteger可以表示不可变的任意精度的整数。`

```
② 要求数字精度比较高的浮点数，用到java.math.BigDecimal类
```

-----------

### 12 集合框架

#### 5.概览

|—-Collection接口：单列集合，用来存储一个一个的对象
|—-List接口：存储有序的、可重复的数据。 –>“动态”数组
`|----ArrayList、LinkedList、Vector`
|—-Set接口：存储无序的、不可重复的数据 –>高中讲的“集合”
|—-HashSet、LinkedHashSet、TreeSet
java.util.Map:存储一对一对的数据
|—-Ｍａｐ接口：存储无序的、不可重复的数据 –>高中讲的“集合” //TODO感觉不对。
|—-HashMap、LinkedHashMap、TreeMap,Hashtable,Properties

[![image.png](http://cdn.this0.com/blog/img/1679233826224-ef45eb1c-77dd-41f9-aba1-924b5169e8b4.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000001&Signature=FfJkfz0dtskqUdtBSto7fp/Z6z4=&x-oss-process=style/cdn.this0)](https://yuling-1318764606.cos.ap-chengdu.myqcloud.com/blog/1679233826224-ef45eb1c-77dd-41f9-aba1-924b5169e8b4.png)

#### 2.Collection接口常用方法：

addAll(Collection coll),

retainsAll(Collection coll), //求两个集合的交集

#### Collection集合与数组间的转换

coll.toArray();

s.`asList(new String[]{"AA", "BB", "CC"});`

向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals(). （ 因为collection中的相关方法contains（）/remove()需要重写,//TODO，为什么）

#### `5.增强for循环`

②不同的集合类底层的数据结构为何？

#### `3.集合框架-List 接口常用方法的测试`

常用方法：(记住)
增：add(Object obj)
删：remove(int index) / remove(Object obj)
`改：set(int index, Object ele) 查：get(int index)`
`插：add(int index, Object ele)`
长度：size()
遍历：① Iterator迭代器方式
② 增强for循环
③ 普通的循环

//TODO，补一个迭代器和增强for循环

#### `4.集合框架-List 不同实现类的对比及课后练习`

 |—-ArrayList：作为List接口的主要实现类；线程不安全的，效率高,`遇到线程安全问题用collection自己包一下`
​ |—-`LinkedList：对于频繁的插入、删除操作`，使用此类效率比ArrayList高；底层使用双向链表存储
​ |—-Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储 `彻底失宠，已经不用了`

[面试题]
面试题：ArrayList、LinkedList、Vector者的异同？
同：三个类都是实现了List接口，存储数据的特点相同：存储序的、可重复的数据
不同：`见上（第3部分+第4部分）//TODO`

#### `5.集合框架-Set 不同实现类的对比及 Set 无序性、不可重复性的剖析`

#### 1.存储的数据特点：无序的、不可重复的元素

 以HashSet为例说明：

##### 1.1`无序性：不等于随机性。存储的数据在底层数组中并非照数组索引的顺序添加，而是根据数据的哈希值决定的。`

##### 1.2不可重复性：保证添加的元素按照equals()判断时，不能返回true.即：相同的元素只能添加一个。

#### 2.元素添加过程：(以HashSet为例)`（老版顺序，先不看）`

jdk 7 :元素a放到数组中，指向原来的元素。 jdk 8 :原来的元素在数组中，指向元素a

#### 3.常用实现类：

 |—-Set接口：存储无序的、不可重复的数据 –>高中讲的“集合”
​ |—-HashSet：作为Set接口的主要实现类；底层用HashMap，即使用`数组+单向链表+红黑树结构进行存储，`
​ |—-LinkedHashSet：作为HashSet的子类；在现有基础上，又添加了一组双向链表，用于记录添加元素的先后顺序
​ `|----TreeSet：底层用红黑树存储，可以按照添加的元素的指定的属性的大小顺序进行遍历`

#### 5.set中无序性，不可重复性的理解的要求：

5.1.无序性：！=随机性
添加元素的顺序和遍历元素的顺序不一致，是不是就是无序性呢？no！
什么是无序性？与添加的元素的位置有关，不像ArrayList一样是一次`紧密排列`的。
这里是根据添加的元素的哈希值，计算的其在数组中的存储位置。此位置不是依次排列的，表现为无序性`（LinkedHashSet也是无序，不过用了链表指向顺序）`
5.2.不可重复性：添加到Set的元素是不能相同的，比较的标准，需要判断hashCode()得到的哈希值、equals()得到的boolean型结果，`哈希值相同且equals()返回true，则认为元素是相同的。`

#### 6.添加到`hashset/linkedhashset`中元素的要求：

 要求元素所在的类`要重写两个方法: equals()和hashCode()。`
​ 同时，`要求equals()和 hashCode()要保持一致性!`我们只需要在IDEA中自动生成两个方法的重写即可，即能保证

#### `6.集合框架-TreeSet 的使用与 Set 接口课后练习`

#### 1.向TreeSet中添加的元素的要求

 `要求是相同类型的对象，否则报异常。`

#### `7.集合框架-Map不同实现类的对比与 HashMap 中元素的特点`

#### 1.常用实现类结构

|—-Map:双列数据，存储key-value对的数据 —类似于高中的函数：y = f(x)
|—-HashMap:作为Map的主要实现类；`线程不安全的`，效率高；`能存储null的key和value`
|—-LinkedHashMap:保证在遍历map元素时，可以照添加的顺序实现遍历。
|—-Hashtable:`作为古老的实现类；线程安全的，效率低；不能存储null的key和value`
|—-TreeMap:保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序，底层使用红黑树
|—-Properties:常用来处理配置文件。key和value都是String类型
`HashMap的底层：数组+链表 （jdk7及之前) 数组+链表+红黑树 （jdk 8)`

#### 2.存储结构的理解：

Map中的key:无序的、不可重复的，使用Set存储所有的key —> `key所在的类要重写equals()和hashCode() （以HashMap为例)`，//TODO为什么啊
Map中的value:无序的、可重复的，使用Collection存储所的value —>`value所在的类要重写equals()`//TODO为什么啊
一个键值对：key-value构成了一个Entry对象。
Map中的entry:无序的、不可重复的，使用Set存储所有的entry

//TODOset常用方法有哪些

`添加：put(Object key,Object value)`
删除：remove(Object key)
修改：put(Object key,Object value)
查询：get(Object key)
长度：size()
遍历：keySet() / values() / entrySet()

#### 1.TreeMap的使用

向TreeMap中添加key-value，要求`key必须是由同一个类创建的对象因为要照key进行排序：自然排序 、定制排序`

Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素`
Object min(Collection)
`Object min(Collection，Comparator)`
`int frequency(Collection，Object)：返回指定集合中指定元素的出现次数

使用synchronizedList(List list） 和 synchronizedMap(Map map）

#### 3.面试题：

面试题：Collection 和 Collections的区别？

-------------

### 13 泛型

泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没任何关系。`
`换句话说，泛型方法所属的类是不是泛型类都没关系。`
`泛型方法，可以声明为静态的。原因：泛型参数是在调用方法时确定的。并非在实例化类时确定。

//TODO，哪种是泛型方法和泛型类？

由于子类在继承带泛型的父类时，指明了泛型类型。则实例化子类对象时，不再需要指明泛型。

2.2. `泛型类的构造器`如下: public GenericClass(){}。
而下面是错误的: public GenericClass(){}

泛型对应的类型均按照Object处理，但不等价 于Object。

如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。

2.9.`在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的泛型。`

参考: `ArrayList源码中声明: Object elementData,而非泛型参数类型数组。`
2.12.父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型:
`●子类不保留父类的泛型:按需实现 ➢没有类型擦除 ➢具体类型 ●子类保留父类的泛型:泛型子类 ➢全部保留 ➢部分保留 结论:子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自 己的泛型`

#### `3.泛型-泛型在继承上的体现及通配符的使用`

A是类B的父类，但是G<A> 和G<B>二者不具备子父类关系，二者是并列关系。通配符章节会出现他们的父类

此时的list1和list2的类型不具子父类关系

通配符：? 类A是类B的父类，G<A>和G<B>是没关系的，二者共同的父类是：G<?>

 `添加(写入)：对于List<?>不能直接向其内部添加数据。 //（因为里面类型不确定）除了添加null之外，直到确定泛型类型`

获取(读取)：泛型允许读取数据，读取的数据类型为Object （因为通配符不知道具体类型，就当object了）。//TODO这个代码要补充

? extends A:
G<? extends A> 可以作为G<A>和G<B>**的子类，其中B是A的子类
? super A:
`G<? super A> 可以作为G<A>和G<B>的父类，其中B是A的父类`**

------

### 14 数据结构与源码

### 1. 数据结构剖析

#### 1.数据的逻辑结构

数据的`逻辑结构指反映数据元素之间的逻辑关系`，而与数据的存储无关，是独立于计算机的。

- **集合结构**：数据结构中的元素之间除了“`同属一个集合`” 的相互关系外，别无其他关系。集合元素之间没有逻辑关系。
- **线性结构**：数据结构中的元素存在`一对一`的相互关系。比如：排队。结构中必须存在唯一的首元素和唯一的尾元素。体现为：一维数组、链表、栈、队列
- **树形结构**：数据结构中的元素存在`一对多`的相互关系。比如：家谱、文件系统、组织架构
- **图形结构**：数据结构中的元素存在`多对多`的相互关系。比如：全国铁路网、地铁图

#### 2 数据的存储结构（或物理结构）

数据的物理结构/存储结构：包括`数据元素的表示`和`关系的表示`

**结构1：顺序结构**

- 顺序结构就是`使用一组连续的存储单元依次存储逻辑上相邻的各个元素。`
- 优点： 只需要申请存放数据本身的内存空间即可，`支持下标访问，也可以实现随机访问。`
- 缺点： 必须静态分配连续空间，内存空间的利用率比较低。插入或删除可能需要移动大量元素，效率比较低

**结构2：链式结构**

- `不使用连续的存储空间存放结构的元素，而是为每一个元素构造一个节点。节点中除了存放数据本身以外，还需要存放指向下一个节点的指针。一次申请一小块内存`
- 优点：不采用连续的存储空间导致内存空间利用率比较高，克服顺序存储结构中预知元素个数的缺点。插入或删除元素时，不需要移动大量的元素。
- 缺点：`需要额外的空间来表达数据之间的逻辑关系，不支持下标访问和随机访问。`

**结构3：索引结构**

- `除建立存储节点信息外，还建立附加的索引表来记录每个元素节点的地址。`索引表由若干索引项组成。索引项的一般形式是：（关键字，地址）。
- 优点：用节点的索引号来确定结点存储地址，检索速度快。
- 缺点： `增加了附加的索引表，会占用较多的存储空间。`在增加和删除数据时要修改索引表，因而会花费较多的时间。

**结构4：散列结构**

- `根据元素的关键字直接计算出该元素的存储地址，又称为Hash存储。`
- 优点：检索、增加和删除结点的操作都很快。
- 缺点：`不支持排序，一般比用线性表存储需要更多的空间，并且记录的关键字不能重复。`//TODO，线性表和索引表是什么

- `在Java中，数组是用来存放同一种数据类型的集合，注意只能存放同一种数据类型。`

### 3. 链表

#### 1.链表的特点

- 逻辑结构：线性结构
- 物理结构：不要求连续的存储空间
- 存储特点：链表由一系列结点node（链表中每一个元素称为结点）组成，结点可以在代码执行过程中动态创建。每个结点包括两个部分：一个是存储数据元素的`数据域`，另一个是存储下一个结点地址的`指针域`。

#### 1 .栈的特点

- 栈`（Stack）又称为堆栈或堆叠，是限制仅在表的一端进行插入和删除运算的线性表。先进后出`
- 核心类库中的`栈结构有Stack和LinkedList。`

队列的修改是依`先进先出（FIFO）的原则`进

### 6. 树与二叉树

#### 1 .树的理解

//TODO,图漏了

**专有名词解释：**
结点：树中的数据元素都称之为结点
根节点：最上面的结点称之为根，一颗树只有一个根且由根发展而来，从另外一个角度来说，每个结点都可以认为是其子树的根
父节点：结点的上层结点，如图中，结点K的父节点是E、结点L的父节点是G
子节点：节点的下层结点，如图中，节点E的子节点是K节点、节点G的子节点是L节点
兄弟节点：具有相同父节点的结点称为兄弟节点，图中F、G、H互为兄弟节点
`结点的度数`：`每个结点所拥有的子树的个数称之为结点的度，如结点B的度为3`
`：度数为0的结点，也叫作终端结点，图中D、K、F、L、H、I、J都是树叶`
非终端节点（或分支节点）：树叶以外的节点，或度数不为0的节点。图中根、A、B、C、E、G都是
树的深度（或高度）：树中结点的最大层次数，图中树的深度为4
`结点的层数`：从根节点到树中某结点所经路径上的分支树称为该结点的层数，根节点的层数规定为1，其余结点的层数等于其父亲结点的层数+1
`同代`：`在同一棵树中具有相同层数的节点`

#### 3. 二叉树的遍历

`哪个序就是根节点放哪的遍历`

- **前序遍历：中左右（根左右）**
  即先访问根结点，再前序遍历左子树，最后再前序遍历右子 树。前序遍历运算访问二叉树各结点是以根、左、右的顺序进行访问的。
- **中序遍历：左中右（左根右）**
  即先中前序遍历左子树，然后再访问根结点，最后再中序遍 历右子树。中序遍历运算访问二叉树各结点是以左、根、右的顺序进行访问的。
- **后序遍历：左右中（左右根）**
  即先后序遍历左子树，然后再后序遍历右子树，最后访问根 结点。后序遍历运算访问二叉树各结点是以左、右、根的顺序进行访问的。

#### 4 .经典二叉树

//TODO这记不住，放一下

### 7. ArrayList 在 JDK7 和 JDK8 中的源码剖析

#### 1.List接口特点

- List集合所有的元素是以一种`线性方式`进行存储的，例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。
- 它是一个元素`存取有序`的集合。即元素的存入顺序和取出顺序有保证。
- 它是一个`带有索引`的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。
- 集合中可以有`重复`的元素，通过元素的equals方法，来比较是否为重复的元素。

##### 2.1 ArrayList与Vector的区别

它们的底层物理结构都是数组，我们称为动态数组。

- ArrayList是新版的动态数组，线程不安全，效率高，Vector是旧版的动态数组，线程安全，效率低。
- 动态数组的扩容机制不同，ArrayList默认扩容为原来的1.5倍，Vector默认扩容增加为原来的2倍。
- 数组的初始化容量，如果在构建ArrayList与Vector的集合对象时，没有显式指定初始化容量，那么Vector的内部数组的初始容量默认为10，`而ArrayList在JDK 6.0 及之前的版本也是10`，`JDK8.0 之后的版本ArrayList初始化为长度为0的空数组，之后在添加第一个元素时，再创建长度为10的数组。`原因：

##### 2.3 ArrayList相关方法图示

- **ArrayList采用数组作为底层实现**
- **ArrayList自动扩容过程**
- **ArrayList的add(E e)方法**
- **ArrayList的add(int index,E e)方法**

#### 2.链表LinkedList

Java中有双链表的实现：LinkedList，它是List接口的实现类。
LinkedList是一个`双向链表`，如图所示：

###### 2.1.2 LinkedList相关方法图示

- **只有1个元素的LinkedList**
- **包含4个元素的LinkedList**
- **add(E e)方法**
- **add(int index,E e)方法**
- **remove(Object obj)方法**
- **remove(int index)方法**

#### 3.【拓展】HashMap的相关问题

##### 3.1说说你理解的哈希算法

hash算法是一种可以从任何数据中提取出其“指纹”的数据摘要算法，它将任意大小的数据映射到一个固定大小的序列上，这个序列被称为hash code、数据摘要或者指纹。比较出名的hash算法有MD5、SHA。hash是具有唯一性且不可逆的，唯一性是指相同的“对象”产生的hash code永远是一样的。

##### 3.2Entry中的hash属性为什么不直接使用key的hashCode()返回值呢？

不管是JDK1.7还是JDK1.8中，都不是直接用key的hashCode值直接与table.length-1计算求下标的，而是先对key的hashCode值进行了一个运算，JDK1.7和JDK1.8关于hash()的实现代码不一样，但是不管怎么样`都是为了提高hash code值与 (table.length-1)的按位与完的结果，尽量的均匀分布。`

##### 3.3HashMap是如何决定某个key-value存在哪个桶的呢？

因为hash值是一个整数，而数组的长度也是一个整数，有两种思路：
`①hash 值 % table.length`会得到一个[0,table.length-1]范围的值，正好是下标范围，但是用%运算效率没有位运算符&高。
`②hash 值 & (table.length-1)`，任何数 & (table.length-1)的结果也一定在[0, table.length-1]范围。

##### 3.4为什么要保持table数组一直是2的n次幂呢？

因为如果数组的长度为2的n次幂，那么`table.length-1的二进制就是一个高位全是0，低位全是1的数字，这样才能保证每一个下标位置都有机会被用到。`

#### 3.【拓展】HashMap的相关问题没做完

--------------

### 14 File类与IO流

如果需要读取或写入文件内容，必须使用IO流来完成。

如果大家开发使用JUnit中的单元测试方法测试，相对路径即为当前Module下。 如果大家使用main()测试，相对路径即为当前的Project下。

[![image.png](http://cdn.this0.com/blog/img/1680507779117-3caf60f9-1c18-4188-8513-baffb6526316.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=11DFymjj94tUvayVxkaN4/QPHHg=&x-oss-process=style/cdn.this0)](http://cdn.this0.com/blog/img/1680507779117-3caf60f9-1c18-4188-8513-baffb6526316.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=11DFymjj94tUvayVxkaN4/QPHHg=&x-oss-process=style/cdn.this0)

蓝框的流需要大家重点关注。

①read()的理解：`返回读入的一个字符。如果达到文件末尾，返回-1`
② 异常的处理：`为了保证流资源一定可以执行关闭操作。需要使用try-catch-finally处理`

如果流使用的构造器是：`FileWriter(file,false) / FileWriter(file):对原文件的覆盖`
如果流使用的构造器是：`FileWriter(file,true):不会对原文件覆盖`

判断fw和fr是否为null，可以保证在资源初始化或关闭的过程中，不会因为空指针而导致程序异常

（字节流可以处理一切文件）

提高读写速度的原因：内部提供了一个缓冲区。`默认情况下是8kb`

```
说明1：先关闭外层的流，再关闭内层的流
说明2：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略.
```

`InputStreamReader：将一个字节的输入流转换为字符的输入流`
解码：字节、字节数组 —>字符数组、字符串
`OutputStreamWriter：将一个字符的输出流转换为字节的输出流`
编码：字符数组、字符串 —> 字节、字节数组
说明：编码决定了解码的方式

```
ObjectOutputStream:内存中的对象--->存储中的文件、通过网络传输出去：序列化过程`
`ObjectInputStream:存储中的文件、通过网络接收过来 --->内存中的对象：反序列化过程
```

补充：ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量

#### `数据流：`

```
DataInputStream 和 DataOutputStream
```

#### `4.随机存取文件流：RandomAccessFile`//TODO

-------------

15 网络编程
