---
title: JavaSE再记忆
tags:
  - 学而时习之
  - JavaSE
categories:
  - 学而时习之
abbrlink: b7352c4c
date: '2024-01-12 1:01'
description: JavaJavaSE再记忆
---

### 1

#### **标识符的命名规范**

1.包名：多单词组成时所有字母都小写：xxxyyyzzz
2.类名、接口名：多单词组成时，**所有单词的首字母大写**：XxxYyyZzz
3.变量名、方法名：多单词组成时，**第一个单词首字母小写，第二个单词开始每个单词首字母大写**：xxxYyyZzz
4.常量名：所有字母都大写。**多单词时每个单词用下划线连接**：XXX_YYY_ZZZ

#### java采用unicode字符集

#### **变量的作用:用于在内存中保存数据**

#### 变量的使用注意事项：

1. 变量必须**先声明才能使用**,否则报错：错误: 找不到符号

2. 变量必须**先初始化值**才能使用,否则，错误: 可能尚未初始化变量age

-------

### 2

#### 计算机底层存储的是整数的**补码**。

#### **补码：正整数的补码与原码一致，负整数的补码是在反码基础上加1**

#### 浮点型系列精度

float：

**精度：可展示小数点后七位，小数点后六位准确，第七位不准确**

double

**精度：可展示小数点后十六位，小数点后十五位准确，第十六位不准确** 

#### **当byte、char、short三种类型的变量做运算时，结果为int型**

short s1 = 10;
//s1 = s1 + 2;//`编译失败`
s1 += 2;//结论：`不会改变变量本身的数据类型`

#### **位运算符的运算过程都是基于补码运算，但是看结果，我们得换成原码，再换成十进制看结果**

#### 如何区分&,|,^是逻辑运算符还是位运算符？

**如果操作数是boolean类型，就是逻辑运算符，如果操作数是整数，那么就是位运算符。**

----------

### 3

#### 如果if-else结构中的执行语句只有一行时，对应的一对{}可以省略的。但是，不建议大家省略。

####  witch结构中的表达式，只能是如下的6种数据类型之一： byte 、short、char、int、枚举类型(JDK5.0新增)、String类型(JDK7.0新增)

####  case 之后只能声明常量。不能声明范围。

#### 时间复杂度 、空间复杂度 （衡量算法的好坏）

#### while(true){ 循环体}，`除循环体外还需要执行小括号里的表达式`

--------------------

### 4

#### `创建数组对象会在内存中开辟一整块连续的空间`

#### 数组元素是char型：0或'\u0000'，而非'0'

#### 数组内存解析

![image.png](http://cdn.this0.com/blog/img/1676455218210-a9e3eb93-f232-4837-b110-7fa3baa24633.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000001&Signature=GOV9zW7Oi5fETbTTRIZ052bmnwU=&x-oss-process=style/cdn.this0)

#### 栈里面放地址，局部变量放栈里面 堆空间开辟结构，放地址值（首地址值)

[![image.png](http://cdn.this0.com/blog/img/1676543604055-cf9577ec-5c1e-4048-8dff-696307dce0d3.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=9XHMxkhwjcWUNvwQii6/5A9q2zA=&x-oss-process=style/cdn.this0)](http://cdn.this0.com/blog/img/1676543604055-cf9577ec-5c1e-4048-8dff-696307dce0d3.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000001&Signature=fDrshKLq6OAEAn9VoYxSqZ2ca40=&x-oss-process=style/cdn.this0)

栈里面放地址，局部变量放栈里面 堆空间开辟结构，放地址值（首地址值)

#### 小知识：一旦程序出现异常，未处理时，就终止执行。

--------------

### 5

面向对象程序设计的**重点是类的设计**
**设计类，就是设计类的成员。**

#### `类的实例化与对象的内存解析`

//TODO

内存解析：
编译完源程序以后，生成一个或多个字节码文件。
我们使用JVM中的类的加载器和解释器对生成的字节码文件进行解释运行。

意味着，需要将字节码文件对应的类加载到内存中，涉及到内存解析。

虚拟机栈，即为平时提到的栈结构。我们将局部变量存储在栈结构中 堆，我们将new出来的结构（比如：数组、对象）加载在堆空间中。

补充：对象的属性（非static的)加载在堆空间中。

方法区：类的加载信息、常量池、静态域

如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。（非static的)

局部变量：没默认初始化值。

#### 2.4 在内存中加载的位置：

属性：加载到堆空间中（非static） 局部变量：加载到栈空间

static、final、abstract来修饰的方法,后面再讲

return关键字后面不可以声明执行语句。

### 7. `方法的内存解析`

### 8. `对象数组的使用及内存解析`

#### 1. 方法的重载的概念

定义：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。

两同一不同:同一个类、相同方法名;参数列表不同：参数个数不同，参数类型不同

```
3 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。`
`4 可变个数形参在方法的形参中，必须声明在末尾`
`5 可变个数形参在方法的形参中,最多只能声明一个可变形参。
```



### `方法应用 3：方法值传递机制的剖析`

#### 2. 针对于方法的参数概念

形参：方法定义时，声明的小括号内的参数。实参：方法调用时，实际传递给形参的数据

递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。

//例6：快排

重写规则

子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写)。

所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；`
`而对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定====”。

#### 1. 属性赋值顺序

总结：属性赋值的先后顺序
① 默认初始化
② 显式初始化
③ 构造器中初始化
④ 通过”对象.方法” 或 “对象.属性”的方式，赋值
以上操作的先后顺序：①- **②-③** -④

②一个无参的公共的构造器（反射造对象用）

#### 4.成员内部类：

 4.1如何创建成员内部类的对象？(静态的，非静态的)
创建`静态`的Dog内部类的实例(静态的成员内部类):
Person.Dog dog = new Person.Dog();

创建非静态的Bird内部类的实例(非静态的成员内部类): Person.Bird bird = new Person.Bird();//错误的，为什么?`
应该用对象去new
`Person p = new Person();`
`Person.Bird bird = p.new Bird();

注意点：
`在局部内部类的方法中（比如：show如果调用局部内部类所声明的方法(比如：method)中的局部变量(比如：num)的话,要求此局部变量声明为final的。`

- jdk 7及之前版本：要求此局部变量显式的声明为final的
  `jdk 8及之后的版本：可以省略final的声明`
  总结：
  成员内部类和局部内部类，在编译以后，都会生成字节码文件。
  `格式：成员内部类：外部类$内部类名.class`
  `局部内部类：外部类$数字 内部类名.class`

---------------

### 6

如果方法的形参和类的属性同名时，我们必须显式的使用"this.变量"的方式，表明此变量是属性，而非形参。

如果构造器的形参和类的属性同名时，我们必须显式的使用"this.变量"的方式，表明此变量是属性，而非形参。

规定："this(形参列表)"必须声明在当前构造器的首行

import:导入

2.5 如果使用的类或接口是java.lang包下定义的，则可以省略import结构。

2.6 如果使用的类或接口是本包下定义的，则可以省略import结构。

2.7 如果在源文件中，使用了不同包下的同名的类，则必须至少一个类需要以全类名的方式示。

2.8 使用"xxx.xx"方式表明可以调用xxx包下的所结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入(xx表示类或接口)。
2.9 import空格static:导入指定类或接口中的静态结构:属性或方法。

我们在类的构造器中，`针对于"this(形参列表)"或"super(形参列表)"只能二一，不能同时出现`

### `关键字 static 修饰属性、方法`

 ③ 由于类只会加载一次，则`静态变量在内存中也只会存在一份：存在方法区的静态域中。`

#### 3.静态变量内存解析：

[![image.png](http://cdn.this0.com/blog/img/1678276130698-3bdabf1e-aae7-4835-aac4-18aae960381d.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=VWjWPbaULlafdVHUq6e6xTME/D4=&x-oss-process=style/cdn.this0)](http://cdn.this0.com/blog/img/1678276130698-3bdabf1e-aae7-4835-aac4-18aae960381d.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=VWjWPbaULlafdVHUq6e6xTME/D4=&x-oss-process=style/cdn.this0)xxxxxxxxxx jdk6及之前，存放在方法区。jdk7及之后，存放在堆空间

#### 5.static的注意点：

##### 5.1 在静态的方法内，不能使用this关键字、super关键字

##### 5.2 关于静态属性和静态方法的使用，大家都从生命周期的角度去理解。

final：最终的

#### 1.可以用来修饰：类、方法、变量

- ```
        static final 用来修饰属性：全局常量
  ```

  

在堆空间中，就会加载所有父类中声明的属性。

当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，...直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中父类中的结构，子类对象才可以考虑进行调用。

[![image.png](http://cdn.this0.com/blog/img/1677380277622-696b5a5e-2a9c-4e0f-8921-6b25c5cbcbc9.png)

虽然创建子类对象时，也调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象(没new不算创建对象)。

[![image.png](http://cdn.this0.com/blog/img/1677380288134-808320bd-9ba7-42bf-af5c-5f2b34d16e5b.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=2VseUyoWbYqa3BVfGgxx491/RIY=&x-oss-process=style/cdn.this0)](http://cdn.this0.com/blog/img/1677380288134-808320bd-9ba7-42bf-af5c-5f2b34d16e5b.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=2VseUyoWbYqa3BVfGgxx491/RIY=&x-oss-process=style/cdn.this0)

### ` Object 类及 clone()、finalize()的理解`

像String、Date、File、包装类等都重写了Object类中的equals()方法。

-----------

### 7

体现三：单例模式（将构造器私有化）

static \ final \ abstract \native 可以用来修饰方法

#### 3 .权限修饰符可用来修饰的结构说明：

四种权限都可以用来修饰类的内部结构：属性、方法、`构造器、内部类`
`修饰类的话，只能使用：缺省、public`

子类继承父类以后，仍然认为获取了父类中私的结构。只因为封装性的影响，使得子类不能直接调用父类的结构而已。

3.多态性的使用：`虚拟方法调用`

对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）

子类中定义了与父类同名同参数的方法，`在多态情况下，将此时父类的方法称为虚拟方法，`父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。

#### 1.关于向上转型与向下转型：

##### 1.1 向上转型：多态(`调用父类的方法`)

#### 2.向下转型(`调用子类的方法`)：

如何才能调用子类特的属性和方法？使用向下转型。

[![image.png](http://cdn.this0.com/blog/img/1677510703246-5dc5f55d-b1c5-45f3-93d9-2bd0e831b02f.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=H7RzYi3/KnumfDvvupT4F5mr3Ao=&x-oss-process=style/cdn.this0)](http://cdn.this0.com/blog/img/1677510703246-5dc5f55d-b1c5-45f3-93d9-2bd0e831b02f.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=H7RzYi3/KnumfDvvupT4F5mr3Ao=&x-oss-process=style/cdn.this0)

#### 3.多态性的理解：

① 实现代码的通用性。`
② Object类中定义的public boolean equals(Object obj){ }
JDBC:使用java程序操作(获取数据库连接、CRUD)数据库(MySQL、Oracle、DB2、SQL Server)
`③ 抽象类、接口的使用肯定体现了多态性。（抽象类、接口不能实例化）

④`作用总结：由于虚拟方法调用，能增加程序拓展性。`

----

### 8

- `抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程）`

#### 3.注意点：

##### 3.1.`abstract不能用来修饰：属性、构造器等结构`

##### 3.2.`abstract不能用来修饰私有方法、静态方法、final的方法、final的类`

### `2.面向对象(高级)-模板方法设计模式(//TODO)`

###### 1.2.1 JDK7及以前：只能定义全局常量和抽象方法

```
         >全局常量：public static final的.但是书写时，可以省略不写
         >抽象方法：public abstract的


     1.3.2 JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法（略）
```

##### 1.6. `接口与接口之间可以继承，而且可以多继承`

### `4面向对象(高级)-JDK8 和 JDK9 中接口的新特性`

知识点1：接口中定义的静态方法，只能通过接口来调用。

知识点2：通过实现类的对象，可以调用接口中的默认方法。

知识点3：`如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没重写此方法的情况下，默认调用的是父类中的同名同参数的方法。-->类优先原则`

1.3如果枚举类中只一个对象，则可以作为单例模式的实现方式。

#### 4.使用enum定义枚举类之后，枚举类常用方法：（继承于java.lang.Enum类）

Season1 summer = Season1.SUMMER;
`toString():返回枚举类对象的名称`
System.out.println(summer.toString());
System.out.println(Season1.class.getSuperclass());
System.out.println(“***\**\*\*\*\*\*\*\*\*\*\*\*“);
`values():返回所有的枚举类对象构成的数组`
Season1[] values = Season1.values();
for(int i = 0;i < values.length;i++){
System.out.println(values[i]);
}
System.out.println(“\*\*\*\*\*\*\*\*\*\*\*\*\****“);
Thread.State[] values1 = Thread.State.values();
for (int i = 0; i < values1.length; i++) {
System.out.println(values1[i]);
}

```
//valueOf(String objName):返回枚举类中对象名是objName的对象。
```



#### 1.注解的理解

```
①Jdk 5.0 新增的功能
```

用来配置应用程序的任何`切面`，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。
框架 = 注解 + 反射机制 + 设计模式

@Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。

#### `如何自定义注解`

 `//TODO要结合反射，先感受一下`

如果注解有成员，在使用注解时，需要指明成员的值。`
`自定义注解必须配上注解的信息处理流程(使用反射)才意义。`
自定义注解通过都会`指明两个元注解：Retention、Target

—>类比：`元数据`的概念：String name = “Tom”;

#### `如何获取注解信息:通过发射来进行获取、调用。`

#### 5.`JDK8中注解的新特性：可重复注解、类型注解`

##### 5.1 `可重复注解：`

```
JAVA
import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME)
public @interface Authors {
    Author[] value();
}
------------------------------------------------

    @Author(name = "Alice")
    @Author(name = "Bob")
    public class MyClass {
        // ...
    }
```

##### 5.2 `类型注解：`

ElementType.TYPE_PARAMETER 表示该注解能写在什么类型变量的声明语句中（如：泛型声明。

ElementType.TYPE_USE 表示该注解能写在任何使用类型的语句中。

单元测试。
此时的Java类要求：① 此类是public的 ②此类提供公共的无参的构造器`(只能有一个？)`
`如果测试类需要进行依赖注入等复杂操作，则可以使用带参数的构造函数，并在测试方法上使用注解来指定运行器应该使用哪个构造函数进行实例化。例如，使用JUnit 4框架时，可以使用@RunWith(Parameterized.class)注解来指定带参数的构造函数。`

此时的单元测试方法：`方法的权限是public,没返回值，没形参`

① Vector类中关于添加元素，只定义了形参为Object类型的方法：`
`v.addElement(Object obj); //基本数据类型 --->包装类 --->使用多态

-----

### 9

像数据库连接、输入输出流、网络编程Socket等资源，`JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。`

#### 5.[面试题]

```
final、finally、finalize三者的区别？
```

throw 和 throws`
`Collection 和 Collections`
`String 、StringBuffer、StringBuilder ArrayList 、 LinkedList HashMap 、LinkedHashMap

throws的方式只是将异常抛给了方法的调用者。并没真正将异常处理掉。

#### 3.体会开发中应该如何选择两种处理方式？

3.1 如果父类中被重写的方法没throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中异常，必须使用try-catch-finally方式处理。`
3.2 执行的方法a中，先后又调用了另外的几个方法，`这几个方法是递进关系执行的。我们建议这几个方法使用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理。

throw `表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内。`

### 5.异常处理-如何自定义异常类及课后练习

如何自定义异常类？

#### 1.继承于现的异常结构：RuntimeException 、Exception

#### 2.`提供全局常量：serialVersionUID (IO流的时候再说)`

#### 3.`通常提供几个重载的构造器`

---------

### 10

