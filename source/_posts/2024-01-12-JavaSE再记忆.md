---
title: JavaSE再记忆
tags:
  - 学而时习之
  - JavaSE
categories:
  - 学而时习之
abbrlink: b7352c4c
date: '2023-04-29 23:39'
description: JavaJavaSE再记忆
updated: 2024-01-07 00:32:24
---

### 1

#### **标识符的命名规范**

1.包名：多单词组成时所有字母都小写：xxxyyyzzz
2.类名、接口名：多单词组成时，**所有单词的首字母大写**：XxxYyyZzz
3.变量名、方法名：多单词组成时，**第一个单词首字母小写，第二个单词开始每个单词首字母大写**：xxxYyyZzz
4.常量名：所有字母都大写。**多单词时每个单词用下划线连接**：XXX_YYY_ZZZ

#### java采用unicode字符集

#### **变量的作用:用于在内存中保存数据**

#### 变量的使用注意事项：

1. 变量必须**先声明才能使用**,否则报错：错误: 找不到符号

2. 变量必须**先初始化值**才能使用,否则，错误: 可能尚未初始化变量age

-------

### 2

#### 计算机底层存储的是整数的**补码**。

#### **补码：正整数的补码与原码一致，负整数的补码是在反码基础上加1**

#### 浮点型系列精度

float：

**精度：可展示小数点后七位，小数点后六位准确，第七位不准确**

double

**精度：可展示小数点后十六位，小数点后十五位准确，第十六位不准确** 

#### **当byte、char、short三种类型的变量做运算时，结果为int型**

short s1 = 10;
//s1 = s1 + 2;//`编译失败`
s1 += 2;//结论：`不会改变变量本身的数据类型`

#### **位运算符的运算过程都是基于补码运算，但是看结果，我们得换成原码，再换成十进制看结果**

#### 如何区分&,|,^是逻辑运算符还是位运算符？

**如果操作数是boolean类型，就是逻辑运算符，如果操作数是整数，那么就是位运算符。**

----------

### 3

#### 如果if-else结构中的执行语句只有一行时，对应的一对{}可以省略的。但是，不建议大家省略。

####  witch结构中的表达式，只能是如下的6种数据类型之一： byte 、short、char、int、枚举类型(JDK5.0新增)、String类型(JDK7.0新增)

####  case 之后只能声明常量。不能声明范围。

#### 时间复杂度 、空间复杂度 （衡量算法的好坏）

#### while(true){ 循环体}，`除循环体外还需要执行小括号里的表达式`

--------------------

### 4

#### `创建数组对象会在内存中开辟一整块连续的空间`

#### 数组元素是char型：0或'\u0000'，而非'0'

#### 数组内存解析

![image.png](http://cdn.this0.com/blog/img/1676455218210-a9e3eb93-f232-4837-b110-7fa3baa24633.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000001&Signature=GOV9zW7Oi5fETbTTRIZ052bmnwU=&x-oss-process=style/cdn.this0)

#### 栈里面放地址，局部变量放栈里面 堆空间开辟结构，放地址值（首地址值)

[![image.png](http://cdn.this0.com/blog/img/1676543604055-cf9577ec-5c1e-4048-8dff-696307dce0d3.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000000&Signature=9XHMxkhwjcWUNvwQii6/5A9q2zA=&x-oss-process=style/cdn.this0)](http://cdn.this0.com/blog/img/1676543604055-cf9577ec-5c1e-4048-8dff-696307dce0d3.png?OSSAccessKeyId=LTAI5tAje5MhbPSKCC6QdGZb&Expires=9000000001&Signature=fDrshKLq6OAEAn9VoYxSqZ2ca40=&x-oss-process=style/cdn.this0)

栈里面放地址，局部变量放栈里面 堆空间开辟结构，放地址值（首地址值)

#### 小知识：一旦程序出现异常，未处理时，就终止执行。

--------------

### 5

面向对象程序设计的**重点是类的设计**
**设计类，就是设计类的成员。**

#### `类的实例化与对象的内存解析`

//TODO

内存解析：
编译完源程序以后，生成一个或多个字节码文件。
我们使用JVM中的类的加载器和解释器对生成的字节码文件进行解释运行。

意味着，需要将字节码文件对应的类加载到内存中，涉及到内存解析。

虚拟机栈，即为平时提到的栈结构。我们将局部变量存储在栈结构中 堆，我们将new出来的结构（比如：数组、对象）加载在堆空间中。

补充：对象的属性（非static的)加载在堆空间中。

方法区：类的加载信息、常量池、静态域

如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。（非static的)

局部变量：没默认初始化值。

#### 2.4 在内存中加载的位置：

属性：加载到堆空间中（非static） 局部变量：加载到栈空间

static、final、abstract来修饰的方法,后面再讲

return关键字后面不可以声明执行语句。

### 7. `方法的内存解析`

### 8. `对象数组的使用及内存解析`

#### 1. 方法的重载的概念

定义：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。

两同一不同:同一个类、相同方法名;参数列表不同：参数个数不同，参数类型不同

```
3 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。`
`4 可变个数形参在方法的形参中，必须声明在末尾`
`5 可变个数形参在方法的形参中,最多只能声明一个可变形参。
```



### `方法应用 3：方法值传递机制的剖析`

#### 2. 针对于方法的参数概念

形参：方法定义时，声明的小括号内的参数。实参：方法调用时，实际传递给形参的数据

递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。

//例6：快排

重写规则

子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写)。

所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；`
`而对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定====”。

#### 1. 属性赋值顺序

总结：属性赋值的先后顺序
① 默认初始化
② 显式初始化
③ 构造器中初始化
④ 通过”对象.方法” 或 “对象.属性”的方式，赋值
以上操作的先后顺序：①- **②-③** -④

②一个无参的公共的构造器（反射造对象用）

#### 4.成员内部类：

 4.1如何创建成员内部类的对象？(静态的，非静态的)
创建`静态`的Dog内部类的实例(静态的成员内部类):
Person.Dog dog = new Person.Dog();

创建非静态的Bird内部类的实例(非静态的成员内部类): Person.Bird bird = new Person.Bird();//错误的，为什么?`
应该用对象去new
`Person p = new Person();`
`Person.Bird bird = p.new Bird();

注意点：
`在局部内部类的方法中（比如：show如果调用局部内部类所声明的方法(比如：method)中的局部变量(比如：num)的话,要求此局部变量声明为final的。`

- jdk 7及之前版本：要求此局部变量显式的声明为final的
  `jdk 8及之后的版本：可以省略final的声明`
  总结：
  成员内部类和局部内部类，在编译以后，都会生成字节码文件。
  `格式：成员内部类：外部类$内部类名.class`
  `局部内部类：外部类$数字 内部类名.class`

---------------

从面向对象初级二开始
